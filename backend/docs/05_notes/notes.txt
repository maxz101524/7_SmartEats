

--------------------------------------------------------------------------------
Week 2 - A2: Project Foundations + Views + Templates
--------------------------------------------------------------------------------

PROGRESS:
- Separate frontend (react) and backend (django)
- Set up split settings pattern (base.py, development.py, production.py)
- Configured environment variables using django-environ
- Added branching strategy documentation
- Implemented all 4 views (2 FBV + 2 CBV) as JSON API endpoints
- Built React frontend with component-based templates and routing
- Created reusable ShowData and component for template reuse


VIEWS 

  1. dining_hall_view (FBV - HttpResponse)
     URL: /api/halls/ (name='dining_hall_list')
     Purpose: Returns all dining halls as JSON using HttpResponse(json.dumps(...))
     This is a manual approach — we serialize the queryset ourselves and wrap
     it in an HttpResponse, demonstrating low-level control over the response.

  2. dish_list_view (FBV - JsonResponse shortcut)
     URL: /api/dishes/ (name='dish_list')
     -Returns dishes with selected fields via JsonResponse (shortcut).
     JsonResponse is analogous to Django's render() 

  3. UserProfileBaseView (CBV - inherits from View)
     URL: /api/profiles/ (name='user_profiles')
     -Returns all user profiles as JSON. Inherits from django.views.View
     and implements the get() method manually. 

  4. MealListView (CBV - inherits from ListView)
     URL: /api/meals/ (name='meal_history')
     - Returns all meals as JSON. Uses Django's generic ListView with
     model = Meal. Overrides render_to_response to return JSON instead of
     an HTML template.

Views — Django-to-React Mapping
-Since we use React as our frontend, our Django views serve as JSON API endpoints rather than 
rendering HTML templates directly. The four required view types (2 FBV + 2 CBV) are all implemented 
in `backend/mealPlanning/views.py` and liked to `backend/mealPlanning/urls.py` with named routes. 
The React frontend then consumes these endpoints and handles the presentation.

-Function-Based Views (FBVs): We implement two FBVs that correspond to the assignment's HttpResponse and render() patterns.
`dining_hall_view` uses `HttpResponse(json.dumps(...))` to manually serialize and return data — this is equivalent to the 
"HttpResponse" approach. `dish_list_view` uses `JsonResponse()`,
which is Django's built-in shortcut that automatically handles serialization and content-type headers — analogous to using 
`render()` as a convenience shortcut. On the frontend, `DiningHalls.tsx` and `Dishes.tsx` consume these endpoints respectively.

-Class-Based Views (CBVs): We implement two CBVs matching the base and generic patterns. `UserProfileBaseView` inherits from
`django.views.View` and manually implements `get()` to query and return data — this is the base CBV approach. `MealListView` 
inherits from `django.views.generic.ListView` with `model = Meal` and overrides `render_to_response` to 
return JSON — this demonstrates how generic views reduce boilerplate by handling the queryset automatically. 
On the frontend, `Profiles.tsx` uses both of these endpoints.

-URL Routing: All four Django URLs use `name=` for named routing. On the React side, `App.tsx` uses React Router's `<Route path=... />` for routing.

VIEWS NOTES (HttpResponse vs render, Base CBV vs Generic CBV):
- HttpResponse gives full control but requires manual serialization  while render() handles this automatically
   so it makes development faster
- Base CBV (View) is flexible because we can write our logic by ourselves, while Generic CBV (ListView) is useful when
  our view maps directly to a model queryset, since it handles the query automatically

TEMPLATES (React):
- Base.tsx acts as our base.html (shared Navbar, Outlet for content, Footer)
- Page components (Dishes.tsx, DiningHalls.tsx, Profiles.tsx) extend the base
  layout via React Router nested routes (equivalent to {% extends "base.html" %})
- .map() replaces {% for %}, Empty.tsx rendering replaces {% empty %}
- ShowData.tsx is a reusable template component shared across pages

