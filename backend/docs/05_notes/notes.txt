
================================================================================
Week 4 — A4: Internal/External APIs, Charts, Exports & Deployment
================================================================================

PART 1: Internal JSON API + Vega-Lite Charts
---------------------------------------------
- Created/confirmed an internal GET JSON endpoint (e.g. /api/summary/)
  backed directly by our Django models, returning "chart-ready" data
  (clean JSON, no HTML) for Vega-Lite.
- Designed the output shape so that Vega-Lite can aggregate by fields
  like dining hall, dish category, or meal type without extra parsing.
- Built two Vega-Lite specs in the online editor that read from
  data: { "url": "https://<our-site>/api/summary/" }:
  * One bar chart for aggregated summaries (e.g., dishes per hall
    or average calories by category).
  * One line or scatter chart for trends / comparisons.
- Embedded both charts into dedicated HTML endpoints (e.g. /vega-lite/bar/
  and /vega-lite/trend/), so they can be viewed in the browser and
  later screenshotted for grading.


PART 2: External API Integration (Keyless)
------------------------------------------
- Integrated a keyless public API via a Django view that accepts
  query parameters (e.g. ?q= or ?dish=) and uses requests.get() with
  params=..., timeout=5, and .raise_for_status() for robust error
  handling.
- Combined the external response with our own in-memory internal data
  (without storing it) to produce a processed/analytics result
  (for example: enriching dishes with external nutrition, ratings,
  or price information).
- Exposed this processed output via a new internal endpoint that
  returns either JSON or a rendered template, making it consistent
  with the rest of our API layer.


PART 3: CSV + JSON Export & Reports
-----------------------------------
- Implemented a CSV export view for one core model (e.g. Dish,
  Meal, or Student-equivalent) that returns:
  Content-Type: text/csv and a Content-Disposition attachment with
  a timestamped filename like model_YYYY-MM-DD_HH-MM.csv.
- Implemented a JSON export view for the same model that wraps data
  in metadata (generated_at, record_count, and a list of objects),
  using JsonResponse(..., json_dumps_params={"indent": 2}) plus a
  timestamped filename.
- Added visible "Download CSV" and "Download JSON" buttons/links on
  a reports/list page so users can easily export data.
- Built a reports template (e.g. reports.html) that shows at least
  two grouped summaries (such as counts per dining hall or category)
  plus a totals line, with proper table headers and {% empty %}
  handling.


PART 4: Static Files & Initial Deployment
-----------------------------------------
- Verified static file configuration for both development and
  production settings: STATIC_URL, STATICFILES_DIRS, and collectstatic
  behavior, keeping the generated staticfiles directory out of Git.
- Confirmed the base template loads static assets correctly with
  {% load static %} and uses {% static %} for CSS/JS; styling is
  visible across multiple pages.
- Created/updated requirements.txt and .gitignore to reflect the
  deployed environment, while intentionally committing db.sqlite3
  for this assignment.
- Cleaned up code for deployment (removed debug prints/unused imports,
  ensured /api/... routes are organized, and templates extend
  base.html) and prepared to clone the repo, set up a virtualenv,
  install requirements, run collectstatic, and serve the app on
  PythonAnywhere.

================================================================================
Week 3 — A3: User Input, Analysis, & APIs
================================================================================

SECTION 1: URL Linking & Navigation
-------------------------------------
get_absolute_url():
- Implemented on Dish and UserProfile models using Django's reverse().
- Dish.get_absolute_url() is useful at the "View Details" button: the API
  serializes it as detail_url, React Router state carries it forward,
  and DishDetail.tsx uses it for the fetch.


SECTION 2: ORM Queries & Data Presentation
--------------------------------------------
- GET search: /api/dishes/?search= uses request.GET.get('search') and
  Dish.objects.filter(dish_name__icontains=query).
- POST search: AIMealView.post() reads request.POST.get('dishes') for
  exact-match lookup — data hidden from URL.
- Relationship spanning: AIMealView filters across TempMeal → TempMealItem
  → Dish using items__dish__dish_name__icontains (Django __ lookups).
- Aggregations: dish_stats_view returns Count (total dishes/halls) and
  annotate + Count (grouped by category and by dining hall).


SECTION 3: Static Files & UI Styling
--------------------------------------
Static file organization choice:
- We place static assets inside the frontend source tree under
  frontend/src/static/ (css/ and images/ subdirectories). And import in main.tsx

CSS approach :
- custom.css remaps Tailwind custom properties (--color-white,
  --color-gray-50 through --color-gray-950, --color-blue-*, --color-green-*,
  etc.) to dark-palette equivalents. 
- The Inter font is loaded via <link> in index.html and set through the
  --font-sans variable that Tailwind v4 reads for its default sans-serif
  stack. 
- The SmartEats logo is stored at src/static/images/smarteats-logo.png and
  imported in Navbar.tsx as a module



SECTION 4: Data Visualization (Matplotlib)
-------------------------------------------
- All charts use ORM queries → Matplotlib → BytesIO → HttpResponse(image/png).
- BytesIO keeps the PNG in memory (no temp files on disk). plt.close(fig)
  frees the figure immediately so RAM doesn't grow with each request.
- DishSummaryImageView: pie chart of a single dish's protein/carbs/fat.
  Served at /api/dish-summary-img/<id>/ and embedded via <img> in
  DishDetail.tsx with alt text.
- dishes_per_hall_png: bar chart — uses annotate(Count) to count dishes
  per dining hall. Served at /api/charts/dishes_per_hall.png.
- MealSummaryView: dual pie chart (macronutrient % + meal category %).
 


SECTION 5: Forms & User Input
-------------------------------
- GET form: Dishes.tsx search bar sends ?search= query params to
  /api/dishes/. URL stays shareable (e.g. /api/dishes/?search=chicken).
- POST form: AddDish.tsx submits JSON body to POST /api/dishes-manage/
  to create a new dish. Data is hidden from the URL.
- CSRF: DishManagementView.get() is decorated with @ensure_csrf_cookie so
  the browser receives the csrftoken cookie on page load. AddDish.tsx reads
  the cookie with getCookie("csrftoken") and sends it as the X-CSRFToken
  header on the POST request.
- CBV handling: DishManagementView (inherits View) handles both methods —
  get() returns the dish list, post() validates input and creates a Dish.


SECTION 6: Creating APIs
--------------------------
API planning:
Since our project uses React, an API would be the primary way to connect the backend and frontend to send data; therefore, 
every piece of data that we want to display in the frontend needs to be passed via an API.

Data served:
- /api/halls/        — dining hall names + locations
- /api/dishes/       — dish catalog, filterable by name (?search=)
- /api/dishes/<id>   — single dish detail
- /api/dish-stats/   — aggregation: total counts + grouped summaries
- /api/profiles/     — user profiles
- /api/meals/        — meal history
- /api/aimeals/      — AI meal search (GET fuzzy / POST exact)
- /api/dishes-manage/ — GET list / POST create dish

HttpResponse vs JsonResponse :
- dining_hall_view: HttpResponse(json.dumps(data), content_type=
  "application/json")
- dish_list_view: JsonResponse(data, safe=False)
- If HttpResponse omits content_type, Django defaults to text/html and
  the browser renders raw text. JsonResponse prevents this mistake.

Filtering via query parameters:
- /api/dishes/?search=chicken — icontains filter on dish_name.
- /api/aimeals/?dishes=Rice,Chicken — splits comma param, chains Q()
  with relationship spanning (items__dish__dish_name__icontains).


================================================================================
Week 2 — A2: Project Foundations + Views + Templates
================================================================================

PROGRESS:
- Separate frontend (React) and backend (Django)
- Split settings pattern (base.py, development.py, production.py)
- Environment variables via django-environ; .env ignored by Git
- All 4 views (2 FBV + 2 CBV) implemented as JSON API endpoints

VIEWS:
  1. dining_hall_view (FBV - HttpResponse)
     URL: /api/halls/ — manual json.dumps() serialization
  2. dish_list_view (FBV - JsonResponse)
     URL: /api/dishes/ — shortcut, auto serialization
  3. UserProfileBaseView (CBV - View)
     URL: /api/profiles/ — manual get() implementation
  4. MealListView (CBV - ListView)
     URL: /api/meals/ — generic view, overrides render_to_response

TEMPLATES (React equivalent):
- Base.tsx = base.html (shared Navbar + Outlet + Footer)
- Page components extend base via React Router nested routes
- .map() replaces {% for %}, Empty.tsx replaces {% empty %}
- ShowData.tsx = reusable template component shared across pages

NOTES (HttpResponse vs render, Base CBV vs Generic CBV):
- HttpResponse: full control, manual serialization
- render() / JsonResponse: automatic, faster development
- Base CBV (View): flexible, write your own logic
- Generic CBV (ListView): less boilerplate when view maps to a model
