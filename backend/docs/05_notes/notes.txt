
================================================================================
Week 4 — A4: Internal/External APIs, Charts, Exports & Deployment
================================================================================

SECTION 1: Internal JSON APIs for Charts
-----------------------------------------
- We continued to expose aggregation data as clean JSON from real Django models
  (e.g., dish and meal statistics) so it is "chart-ready" for Vega-Lite: each
  object already contains the x-axis key and metric field(s) (like date,
  dining_hall, category, or meal count).
- These JSON endpoints only return serialized data (no HTML), using
  JsonResponse(..., safe=False) or dict-shaped responses, which makes them usable
  both by our React frontend and by external tools like the Vega-Lite editor.
- In production, these APIs are reachable at /api/... URLs on PythonAnywhere, so
  classmates can point Vega-Lite's data.url directly at our deployed endpoints.


SECTION 2: External API Integration (Wger)
-------------------------------------------
- Implemented nutrition lookup at the view function `nutrition_lookup_view`
  using a keyless public API: Wger's ingredient endpoint
  (https://wger.de/api/v2/ingredient/).
- The view accepts a `?q=` query parameter, calls http_requests.get() with
  params (name, language, format, limit), sets timeout=5, and uses
  .raise_for_status() inside try/except blocks to handle timeouts and
  RequestException cleanly.
- The JSON body from Wger is normalized into a compact list of external_items
  with per_100g macros (kcal, protein, carbohydrates, fat, fiber, sodium).
- In parallel, we query our own Dish model with dish_name__icontains=query and
  join related dining hall information; this gives us internal_matches that we
  do NOT persist back into the database.
- The response combines both sources plus optional analytics per user:
  if a netID is provided, we look up UserProfile, compute BMR/TDEE using
  Mifflin-St Jeor, derive daily macro targets based on goal (fat_loss or
  muscle_gain), compare against today's Meal intake, and return remaining macros.
- Final output is a single JsonResponse with keys:
  query, external_results, internal_matches, and user_analysis, demonstrating
  triangulation between external and internal data without storing the external
  API payload.


SECTION 3: CSV + JSON Export of Meals
--------------------------------------
- Implemented `export_meals` view that exports historical Meal records for the
  current user (temporarily using the first UserProfile until auth is wired).
- The view reads ?format= from the query string (csv or json, default csv).
- For JSON export:
  - We build a list of plain dicts for each meal (meal_id, total_calories,
    total_protein, total_carbohydrates, total_fat, date).
  - We wrap it with metadata: generated_at ISO timestamp and record_count.
  - We return JsonResponse(data, json_dumps_params={"indent": 2}) and set
    Content-Disposition to attachment; filename="my_meals_YYYY-MM-DD_HH-MM.json".
- For CSV export:
  - We return HttpResponse(content_type="text/csv") and set Content-Disposition
    with a timestamped "my_meals_YYYY-MM-DD_HH-MM.csv" filename.
  - We write one header row followed by one row per Meal using csv.writer.
- These exports are linked from the reports UI as "Download CSV" / "Download JSON"
  so users can download their historical data in both formats.


SECTION 4: Reports Page & Aggregated Summaries
-----------------------------------------------
- Implemented `MealReportsView` (class-based View) that aggregates Meal data for
  a (temporary) current user and returns a structured JSON report.
- The view supports optional start/end date filters (YYYY-MM-DD) and computes:
  - total_count of meals,
  - category_stats: meals.values("category").annotate(num=Count("pk")),
  - macro totals via aggregate(Sum(...)) for calories, protein, carbs, and fat.
- From these, we derive labels/values arrays for macros and categories, which are
  used to generate a Matplotlib figure (two side-by-side pie charts) rendered to
  a base64 PNG string.
- The JsonResponse payload includes user_info, statistics (totals + grouped
  summaries), and chart_base64 (data:image/png;base64,...) so the frontend can
  show a visual report alongside totals.


SECTION 5: Static Files, Vega-Lite, and Deployment Prep
--------------------------------------------------------
- Updated settings to allow embedding Vega/Vega-Lite from https://vega.github.io
  in production (CSP / allowed hosts in base.py and production.py).
- Verified static file configuration in development and production: STATIC_URL,
  STATICFILES_DIRS, and collectstatic behavior, keeping the collected staticfiles
  directory out of Git to avoid bloating the repo.
- Confirmed the base template (and React entry) use {% load static %} and
  {% static %} for CSS/JS so styling loads correctly on multiple pages.
- Prepared deployment flow for PythonAnywhere: commit db.sqlite3 for this
  assignment, push code + requirements.txt, create a virtualenv on the server,
  pip install -r requirements.txt, run collectstatic with production settings,
  and wire the WSGI config to serve SmartEats.


================================================================================
Week 3 — A3: User Input, Analysis, & APIs
================================================================================

SECTION 1: URL Linking & Navigation
-------------------------------------
get_absolute_url():
- Implemented on Dish and UserProfile models using Django's reverse().
- Dish.get_absolute_url() is useful at the "View Details" button: the API
  serializes it as detail_url, React Router state carries it forward,
  and DishDetail.tsx uses it for the fetch.


SECTION 2: ORM Queries & Data Presentation
--------------------------------------------
- GET search: /api/dishes/?search= uses request.GET.get('search') and
  Dish.objects.filter(dish_name__icontains=query).
- POST search: AIMealView.post() reads request.POST.get('dishes') for
  exact-match lookup — data hidden from URL.
- Relationship spanning: AIMealView filters across TempMeal → TempMealItem
  → Dish using items__dish__dish_name__icontains (Django __ lookups).
- Aggregations: dish_stats_view returns Count (total dishes/halls) and
  annotate + Count (grouped by category and by dining hall).


SECTION 3: Static Files & UI Styling
--------------------------------------
Static file organization choice:
- We place static assets inside the frontend source tree under
  frontend/src/static/ (css/ and images/ subdirectories). And import in main.tsx

CSS approach :
- custom.css remaps Tailwind custom properties (--color-white,
  --color-gray-50 through --color-gray-950, --color-blue-*, --color-green-*,
  etc.) to dark-palette equivalents. 
- The Inter font is loaded via <link> in index.html and set through the
  --font-sans variable that Tailwind v4 reads for its default sans-serif
  stack. 
- The SmartEats logo is stored at src/static/images/smarteats-logo.png and
  imported in Navbar.tsx as a module



SECTION 4: Data Visualization (Matplotlib)
-------------------------------------------
- All charts use ORM queries → Matplotlib → BytesIO → HttpResponse(image/png).
- BytesIO keeps the PNG in memory (no temp files on disk). plt.close(fig)
  frees the figure immediately so RAM doesn't grow with each request.
- DishSummaryImageView: pie chart of a single dish's protein/carbs/fat.
  Served at /api/dish-summary-img/<id>/ and embedded via <img> in
  DishDetail.tsx with alt text.
- dishes_per_hall_png: bar chart — uses annotate(Count) to count dishes
  per dining hall. Served at /api/charts/dishes_per_hall.png.
- MealSummaryView: dual pie chart (macronutrient % + meal category %).
 


SECTION 5: Forms & User Input
-------------------------------
- GET form: Dishes.tsx search bar sends ?search= query params to
  /api/dishes/. URL stays shareable (e.g. /api/dishes/?search=chicken).
- POST form: AddDish.tsx submits JSON body to POST /api/dishes-manage/
  to create a new dish. Data is hidden from the URL.
- CSRF: DishManagementView.get() is decorated with @ensure_csrf_cookie so
  the browser receives the csrftoken cookie on page load. AddDish.tsx reads
  the cookie with getCookie("csrftoken") and sends it as the X-CSRFToken
  header on the POST request.
- CBV handling: DishManagementView (inherits View) handles both methods —
  get() returns the dish list, post() validates input and creates a Dish.


SECTION 6: Creating APIs
--------------------------
API planning:
Since our project uses React, an API would be the primary way to connect the backend and frontend to send data; therefore, 
every piece of data that we want to display in the frontend needs to be passed via an API.

Data served:
- /api/halls/        — dining hall names + locations
- /api/dishes/       — dish catalog, filterable by name (?search=)
- /api/dishes/<id>   — single dish detail
- /api/dish-stats/   — aggregation: total counts + grouped summaries
- /api/profiles/     — user profiles
- /api/meals/        — meal history
- /api/aimeals/      — AI meal search (GET fuzzy / POST exact)
- /api/dishes-manage/ — GET list / POST create dish

HttpResponse vs JsonResponse :
- dining_hall_view: HttpResponse(json.dumps(data), content_type=
  "application/json")
- dish_list_view: JsonResponse(data, safe=False)
- If HttpResponse omits content_type, Django defaults to text/html and
  the browser renders raw text. JsonResponse prevents this mistake.

Filtering via query parameters:
- /api/dishes/?search=chicken — icontains filter on dish_name.
- /api/aimeals/?dishes=Rice,Chicken — splits comma param, chains Q()
  with relationship spanning (items__dish__dish_name__icontains).


================================================================================
Week 2 — A2: Project Foundations + Views + Templates
================================================================================

PROGRESS:
- Separate frontend (React) and backend (Django)
- Split settings pattern (base.py, development.py, production.py)
- Environment variables via django-environ; .env ignored by Git
- All 4 views (2 FBV + 2 CBV) implemented as JSON API endpoints

VIEWS:
  1. dining_hall_view (FBV - HttpResponse)
     URL: /api/halls/ — manual json.dumps() serialization
  2. dish_list_view (FBV - JsonResponse)
     URL: /api/dishes/ — shortcut, auto serialization
  3. UserProfileBaseView (CBV - View)
     URL: /api/profiles/ — manual get() implementation
  4. MealListView (CBV - ListView)
     URL: /api/meals/ — generic view, overrides render_to_response

TEMPLATES (React equivalent):
- Base.tsx = base.html (shared Navbar + Outlet + Footer)
- Page components extend base via React Router nested routes
- .map() replaces {% for %}, Empty.tsx replaces {% empty %}
- ShowData.tsx = reusable template component shared across pages

NOTES (HttpResponse vs render, Base CBV vs Generic CBV):
- HttpResponse: full control, manual serialization
- render() / JsonResponse: automatic, faster development
- Base CBV (View): flexible, write your own logic
- Generic CBV (ListView): less boilerplate when view maps to a model
