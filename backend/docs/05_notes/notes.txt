
================================================================================
Week 3 — A3: User Input, Analysis, & APIs
================================================================================

SECTION 1: URL Linking & Navigation
-------------------------------------
get_absolute_url():
- Implemented on Dish and UserProfile models using Django's reverse().
- Dish.get_absolute_url() is useful at the "View Details" button: the API
  serializes it as detail_url, React Router state carries it forward,
  and DishDetail.tsx uses it for the fetch.


SECTION 2: ORM Queries & Data Presentation
--------------------------------------------
- GET search: /api/dishes/?search= uses request.GET.get('search') and
  Dish.objects.filter(dish_name__icontains=query).
- POST search: AIMealView.post() reads request.POST.get('dishes') for
  exact-match lookup — data hidden from URL.
- Relationship spanning: AIMealView filters across TempMeal → TempMealItem
  → Dish using items__dish__dish_name__icontains (Django __ lookups).
- Aggregations: dish_stats_view returns Count (total dishes/halls) and
  annotate + Count (grouped by category and by dining hall).


SECTION 3: Static Files & UI Styling
--------------------------------------
Static file organization choice:
- We place static assets inside the frontend source tree under
  frontend/src/static/ (css/ and images/ subdirectories). And import in main.tsx

CSS approach :
- custom.css remaps Tailwind custom properties (--color-white,
  --color-gray-50 through --color-gray-950, --color-blue-*, --color-green-*,
  etc.) to dark-palette equivalents. 
- The Inter font is loaded via <link> in index.html and set through the
  --font-sans variable that Tailwind v4 reads for its default sans-serif
  stack. 
- The SmartEats logo is stored at src/static/images/smarteats-logo.png and
  imported in Navbar.tsx as a module



SECTION 4: Data Visualization (Matplotlib)
-------------------------------------------
- All charts use ORM queries → Matplotlib → BytesIO → HttpResponse(image/png).
- BytesIO keeps the PNG in memory (no temp files on disk). plt.close(fig)
  frees the figure immediately so RAM doesn't grow with each request.
- DishSummaryImageView: pie chart of a single dish's protein/carbs/fat.
  Served at /api/dish-summary-img/<id>/ and embedded via <img> in
  DishDetail.tsx with alt text.
- dishes_per_hall_png: bar chart — uses annotate(Count) to count dishes
  per dining hall. Served at /api/charts/dishes_per_hall.png.
- MealSummaryView: dual pie chart (macronutrient % + meal category %).
 


SECTION 5: Forms & User Input
-------------------------------
- GET form: Dishes.tsx search bar sends ?search= query params to
  /api/dishes/. URL stays shareable (e.g. /api/dishes/?search=chicken).
- POST form: AddDish.tsx submits JSON body to POST /api/dishes-manage/
  to create a new dish. Data is hidden from the URL.
- CSRF: DishManagementView.get() is decorated with @ensure_csrf_cookie so
  the browser receives the csrftoken cookie on page load. AddDish.tsx reads
  the cookie with getCookie("csrftoken") and sends it as the X-CSRFToken
  header on the POST request.
- CBV handling: DishManagementView (inherits View) handles both methods —
  get() returns the dish list, post() validates input and creates a Dish.


SECTION 6: Creating APIs
--------------------------
API planning:
Since our project uses React, an API would be the primary way to connect the backend and frontend to send data; therefore, 
every piece of data that we want to display in the frontend needs to be passed via an API.

Data served:
- /api/halls/        — dining hall names + locations
- /api/dishes/       — dish catalog, filterable by name (?search=)
- /api/dishes/<id>   — single dish detail
- /api/dish-stats/   — aggregation: total counts + grouped summaries
- /api/profiles/     — user profiles
- /api/meals/        — meal history
- /api/aimeals/      — AI meal search (GET fuzzy / POST exact)
- /api/dishes-manage/ — GET list / POST create dish

HttpResponse vs JsonResponse :
- dining_hall_view: HttpResponse(json.dumps(data), content_type=
  "application/json")
- dish_list_view: JsonResponse(data, safe=False)
- If HttpResponse omits content_type, Django defaults to text/html and
  the browser renders raw text. JsonResponse prevents this mistake.

Filtering via query parameters:
- /api/dishes/?search=chicken — icontains filter on dish_name.
- /api/aimeals/?dishes=Rice,Chicken — splits comma param, chains Q()
  with relationship spanning (items__dish__dish_name__icontains).


================================================================================
Week 2 — A2: Project Foundations + Views + Templates
================================================================================

PROGRESS:
- Separate frontend (React) and backend (Django)
- Split settings pattern (base.py, development.py, production.py)
- Environment variables via django-environ; .env ignored by Git
- All 4 views (2 FBV + 2 CBV) implemented as JSON API endpoints

VIEWS:
  1. dining_hall_view (FBV - HttpResponse)
     URL: /api/halls/ — manual json.dumps() serialization
  2. dish_list_view (FBV - JsonResponse)
     URL: /api/dishes/ — shortcut, auto serialization
  3. UserProfileBaseView (CBV - View)
     URL: /api/profiles/ — manual get() implementation
  4. MealListView (CBV - ListView)
     URL: /api/meals/ — generic view, overrides render_to_response

TEMPLATES (React equivalent):
- Base.tsx = base.html (shared Navbar + Outlet + Footer)
- Page components extend base via React Router nested routes
- .map() replaces {% for %}, Empty.tsx replaces {% empty %}
- ShowData.tsx = reusable template component shared across pages

NOTES (HttpResponse vs render, Base CBV vs Generic CBV):
- HttpResponse: full control, manual serialization
- render() / JsonResponse: automatic, faster development
- Base CBV (View): flexible, write your own logic
- Generic CBV (ListView): less boilerplate when view maps to a model
